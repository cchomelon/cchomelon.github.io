<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>On Turbulent Cascade</title>
    <link rel="stylesheet" href="/han.min.css">
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="/github-markdown.css">
    <link rel="stylesheet" href="/markdown.css">
    <link rel="stylesheet" href="/physics.css">
    <link rel="stylesheet" href="/syntax.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <link rel="stylesheet" href="https://fred-wang.github.io/MathFonts/NewComputerModern/mathfonts.css" />
    <link rel="stylesheet" href="https://rawcdn.githack.com/iliakonnov/linlibertine/adbbf477b8e554087bf8a9856c494d1656b55900/linlibertine.css" integrity="sha384-vnKhUa5fs2wlv0J+dROs23QJaYX/31FIsBR2QCxiq/hAb3/J6BYVN0FZIwtN7tM5" crossorigin="anonymous">
    <script src="//unpkg.com/han-css/dist/han.min.js" defer></script>
  </head>
  <body>
    <table class="page-frame" width="80%" align="center" border="1">
      <tr>
        <td>
          
            
            
              <div class="typo-physics">
                <p>The usual Kolmogorov-Richardson Cascade has long been a well-received picture, a phenomenological one, not a theorem. In 3D incompressible turbulence, the forward cascade is what one typically see on average, as the nonlinear dynamics have many efficient channels moving energy downscale. But those same equations can also contain hidden channels moving energy upscale.</p>
<h2 id="parity-symmetry-and-helicity" tabindex="-1">Parity symmetry and helicity</h2>
<p>Consider the incompressible Navier-Stokes for velocity <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">u(x,t)</annotation></semantics></math></span>:</p>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="normal">∂</mi><mi>t</mi></msub><mi mathvariant="bold">u</mi><mo>+</mo><mo stretchy="false">(</mo><mi mathvariant="bold">u</mi><mo>⋅</mo><mi mathvariant="normal">∇</mi><mo stretchy="false">)</mo><mi mathvariant="bold">u</mi><mo>=</mo><mo>−</mo><mi mathvariant="normal">∇</mi><mi>p</mi><mi mathvariant="normal">/</mi><mi>ρ</mi><mo>+</mo><mi>ν</mi><mi mathvariant="normal">Δ</mi><mi mathvariant="bold">u</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\partial_{t} \mathbf{u}+(\mathbf{u}\cdot \nabla)\mathbf{u} = -\nabla p/\rho + \nu \Delta \mathbf{u}.
</annotation></semantics></math></span></p>
<p>A transformation <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span> is a symmetry if plugging in the transformed field still satisfies the same equation. Parity is the spatial inversion,</p>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="script">P</mi><mo>:</mo><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mi mathvariant="bold">x</mi><mo separator="true">,</mo><mrow><mi mathvariant="bold">u</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo separator="true">,</mo><mi mathvariant="bold">t</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">)</mo><mo>↦</mo><mo stretchy="false">(</mo><mi>t</mi><mo separator="true">,</mo><mo>−</mo><mi mathvariant="bold">x</mi><mo separator="true">,</mo><mo>−</mo><mi mathvariant="bold">u</mi><mo stretchy="false">(</mo><mo>−</mo><mi mathvariant="bold">x</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathcal{P}: (t, \mathbf{x}, \mathbf{u(\mathbf{x},t)}) \mapsto (t, -\mathbf{x}, -\mathbf{u}(-\mathbf{x},t)).
</annotation></semantics></math></span></p>
<p>Under this map, the equation keeps the same form. You can relabel <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">y</mi><mo>=</mo><mo>−</mo><mi mathvariant="bold">x</mi></mrow><annotation encoding="application/x-tex">\mathbf{y}=-\mathbf{x}</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">v</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mi mathvariant="bold">u</mi><mo stretchy="false">(</mo><mo>−</mo><mi mathvariant="bold">x</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{v}(\mathbf{y},t)=-\mathbf{u}(-\mathbf{x},t)</annotation></semantics></math></span>. So the equations themselves do not prefer left-handed or right-handed structures. This matters because if the solutions or statistics do prefer one-handedness, then that preference is not imposed by the equation; it is a property of the flow state, i.e. parity symmetry breaking (宇稱對稱破缺).</p>
<p>A standard scalar measuring handedness in 3D fluids is helicity.</p>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="script">H</mi><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><mi mathvariant="bold">u</mi><mo>⋅</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∇</mi><mo>×</mo><mi mathvariant="bold">u</mi><mo stretchy="false">)</mo><mtext>  </mtext><mi>d</mi><mi>V</mi><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><mi mathvariant="bold">u</mi><mo>⋅</mo><mi mathvariant="bold">ω</mi><mtext>  </mtext><mi>d</mi><mi>V</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">\mathcal{H} = \int_{\Omega} \mathbf{u} \cdot (\nabla \times \mathbf{u})\;dV = \int_{\Omega}\mathbf{u}\cdot \mathbf{\omega} \;dV,
</annotation></semantics></math></span></p>
<p>is the inner product of velocity and vorticity. Think of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">ω</mi></mrow><annotation encoding="application/x-tex">\mathbf{\omega}</annotation></semantics></math></span> giving the local rotation axis and strength, and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">u</mi><mo>⋅</mo><mi mathvariant="bold">ω</mi></mrow><annotation encoding="application/x-tex">\mathbf{u}\cdot \mathbf{\omega}</annotation></semantics></math></span> telling whether the flow tends to move along its own rotation (one-handedness) or against it.<br>
In inviscid Euler, energy and helicity are the two classical invariants. Energy is positive definite, but helicity is sign-indefinite. Under parity, helicity changes sign,</p>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="script">P</mi><mi mathvariant="script">H</mi><mo>=</mo><mo>−</mo><mi mathvariant="script">H</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathcal{P}\mathcal{H}=-\mathcal{H}.
</annotation></semantics></math></span></p>
<p>So helicity is a pseudo-scalar. Hence, a nonzero net helicity signals parity breaking in the statistical sense.</p>
<p>For incompressible flow, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∇</mi><mo>⋅</mo><mi mathvariant="bold">u</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\nabla \cdot \mathbf{u}=0</annotation></semantics></math></span> becomes <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">k</mi><mo>⋅</mo><mover accent="true"><mi mathvariant="bold">u</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi mathvariant="bold">k</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathbf{k}\cdot \mathbf{\hat{u}}(\mathbf{k})=0</annotation></semantics></math></span> in Fourier space. That means each Fourier mode has only two independent components (the velocity is orthogonal to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">k</mi></mrow><annotation encoding="application/x-tex">\mathbf{k}</annotation></semantics></math></span>).</p>
<p>A convenient way to represent those two components, especially when thinking in spherical geometry in <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">k</mi></mrow><annotation encoding="application/x-tex">\mathbf{k}</annotation></semantics></math></span>-space, is a poloidal-toroidal decomposition. One introduce a local orthonormal frame tied to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">k</mi></mrow><annotation encoding="application/x-tex">\mathbf{k}</annotation></semantics></math></span>,</p>
<ol>
<li><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">3</mn></msub><mo>=</mo><mi mathvariant="bold">k</mi><mi mathvariant="normal">/</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">\mathbf{e_3} = \mathbf{k}/k</annotation></semantics></math></span>,</li>
<li><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">1</mn></msub><mo>∝</mo><mi mathvariant="bold">k</mi><mo>×</mo><mi mathvariant="bold">n</mi></mrow><annotation encoding="application/x-tex">\mathbf{e_1}\propto \mathbf{k} \times \mathbf{n}</annotation></semantics></math></span> (toroidal),</li>
<li><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mn>2</mn></msub><mo>=</mo><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">3</mn></msub><mo>×</mo><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">1</mn></msub></mrow><annotation encoding="application/x-tex">e_{2}=\mathbf{e_3} \times \mathbf{e_1}</annotation></semantics></math></span> (poloidal),<br>
so the incompressible mode is</li>
</ol>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi mathvariant="bold">u</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi mathvariant="bold">k</mi><mo stretchy="false">)</mo><mo>=</mo><mover accent="true"><msub><mi>u</mi><mn>1</mn></msub><mo>^</mo></mover><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">1</mn></msub><mo>+</mo><mover accent="true"><msub><mi>u</mi><mn>2</mn></msub><mo>^</mo></mover><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">2</mn></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\hat{\mathbf{u}}(\mathbf{k})=\hat{u_{1}}\mathbf{e_1} + \hat{u_{2}}\mathbf{e_2}.
</annotation></semantics></math></span></p>
<p>Now, we have isolated the two transverse degrees of freedom in a geometrically clean basis.</p>
<p>The key move is to rotate from <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">1</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{e_1},\mathbf{e_2})</annotation></semantics></math></span> into helical basis vectors (helical Fourier decomposition),</p>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi mathvariant="bold">h</mi><mi mathvariant="bold">s</mi></msup><mo stretchy="false">(</mo><mi mathvariant="bold">k</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mn>2</mn></msqrt></mfrac><mo stretchy="false">[</mo><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">2</mn></msub><mo stretchy="false">(</mo><mi mathvariant="bold">k</mi><mo stretchy="false">)</mo><mo>−</mo><mi>i</mi><mi>s</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">1</mn></msub><mo stretchy="false">(</mo><mi mathvariant="bold">k</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>s</mi><mo>=</mo><mo>±</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{h^s}(\mathbf{k})=\frac{1}{\sqrt{2 }}[\mathbf{e_2}(\mathbf{k})-is\mathbf{e_1}(\mathbf{k})], s=\pm.
</annotation></semantics></math></span></p>
<p>Then any incompressible Fourier mode can be written as,</p>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi mathvariant="bold">u</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi mathvariant="bold">k</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mover accent="true"><mi>u</mi><mo>^</mo></mover><mo>+</mo></msup><mo stretchy="false">(</mo><mi mathvariant="bold">k</mi><mo stretchy="false">)</mo><msup><mi mathvariant="bold">h</mi><mo>+</mo></msup><mo stretchy="false">(</mo><mi mathvariant="bold">k</mi><mo stretchy="false">)</mo><mo>+</mo><mover accent="true"><mi>u</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi mathvariant="bold">k</mi><mo stretchy="false">)</mo><msup><mi mathvariant="bold">h</mi><mo>−</mo></msup><mo stretchy="false">(</mo><mi mathvariant="bold">k</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\hat{\mathbf{u}}(\mathbf{k})=\hat{u}^+ (\mathbf{k}) \mathbf{h}^+ (\mathbf{k})+\hat{u}(\mathbf{k})\mathbf{h}^-(\mathbf{k}).
</annotation></semantics></math></span></p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">h</mi><mo>±</mo></msup></mrow><annotation encoding="application/x-tex">\mathbf{h}^\pm</annotation></semantics></math></span> are eigenvectors of the curl operator in Fourier space,</p>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>i</mi><mi mathvariant="bold">k</mi><mo>×</mo><msup><mi mathvariant="bold">h</mi><mo>±</mo></msup><mo>=</mo><mo>±</mo><mi>k</mi><msup><mi mathvariant="bold">h</mi><mo>±</mo></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">i\mathbf{k} \times \mathbf{h}^\pm = \pm k \mathbf{h}^\pm.
</annotation></semantics></math></span></p>
<p>So the <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo></mrow><annotation encoding="application/x-tex">-</annotation></semantics></math></span> components are literally right/left circularly polarized helical waves. In this basis, the helicity density at mode <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">k</mi></mrow><annotation encoding="application/x-tex">\mathbf{k}</annotation></semantics></math></span> becomes</p>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi mathvariant="script">H</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi mathvariant="bold">k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><msup><mover accent="true"><mi>u</mi><mo>^</mo></mover><mo>+</mo></msup><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>−</mo><mi mathvariant="normal">∣</mi><msup><mover accent="true"><mi>u</mi><mo>^</mo></mover><mo>−</mo></msup><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\hat{\mathcal{H}}(\mathbf{k})=k(|\hat{u}^+|^2 - |\hat{u}^-|^2).
</annotation></semantics></math></span></p>
<p>This makes the parity question very concrete: parity symmetry breaking means one helical sector dominates.</p>
<p>In Fourier space, the incompressible Navier-Stokes is,</p>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><msub><mi mathvariant="normal">∂</mi><mi>t</mi></msub><mo>+</mo><mi>ν</mi><msup><mi>k</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mover accent="true"><msub><mi>u</mi><mi>i</mi></msub><mo>^</mo></mover><mo stretchy="false">(</mo><mi mathvariant="bold">k</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mi>i</mi><msub><mi>k</mi><mi>l</mi></msub><msub><mi>P</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><munder><mo>∑</mo><mi>p</mi></munder><mover accent="true"><msub><mi>u</mi><mi>j</mi></msub><mo>^</mo></mover><mo stretchy="false">(</mo><mi mathvariant="bold">p</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><msub><mover accent="true"><mi>u</mi><mo>^</mo></mover><mi>l</mi></msub><mo stretchy="false">(</mo><mi mathvariant="bold">k</mi><mo>−</mo><mi mathvariant="bold">p</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">(\partial_{t}+\nu k^2)\hat{u_{i}}(\mathbf{k},t)=-ik_{l}P_{ij}\sum_{p}\hat{u_{j}}(\mathbf{p},t)\hat{u}_{l}(\mathbf{k}-\mathbf{p},t),
</annotation></semantics></math></span></p>
<p>where <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>δ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>−</mo><msub><mi>k</mi><mi>j</mi></msub><msub><mi>k</mi><mi>k</mi></msub><mi mathvariant="normal">/</mi><msup><mi>k</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">P_{ij}=\delta_{ij}-k_{j}k_{k}/k^2</annotation></semantics></math></span> is the projection operator. The nonlinear term couples modes only in triads,</p>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">k</mi><mo>+</mo><mi mathvariant="bold">p</mi><mo>+</mo><mi mathvariant="bold">q</mi><mo>=</mo><mn>0.</mn></mrow><annotation encoding="application/x-tex">\mathbf{k}+\mathbf{p}+\mathbf{q}=0.
</annotation></semantics></math></span></p>
<p>This triadic interaction is the fundamental unit of energy transfer across scales. When you express Navier-Stokes in the helical basis, each mode carries a sign <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mo>±</mo></mrow><annotation encoding="application/x-tex">s=\pm</annotation></semantics></math></span>. A triad therefore has combinations of of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>s</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>s</mi><mi>p</mi></msub><mo separator="true">,</mo><msub><mi>s</mi><mi>q</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(s_{k},s_{p},s_{q})</annotation></semantics></math></span>. There are 8 sign combinations in principle, but symmetry reduces the essential to a smaller set,</p>
<ol>
<li>Homochiral triads: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>+</mo><mo separator="true">,</mo><mo>+</mo><mo separator="true">,</mo><mo>+</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(+,+,+)</annotation></semantics></math></span> or <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mo separator="true">,</mo><mo>−</mo><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-,-,-)</annotation></semantics></math></span></li>
<li>Heterochiral triads: mixed signs, e.g. <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>+</mo><mo separator="true">,</mo><mo>+</mo><mo separator="true">,</mo><mo>−</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(+,+,-)</annotation></semantics></math></span>, etc.</li>
</ol>
<p>Assume wavenumbers ordered by magnitude <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≤</mo><mi>p</mi><mo>≤</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">k \leq p\leq q</annotation></semantics></math></span>. <a href="https://doi.org/10.1063/1.858309">Waleffe (1992)</a> used stability arguments to show that, in homochiral triads, the intermediate mode <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span> tends to lose energy to both <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span>, with a bias that favors transfer toward the smallest wavenumber <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span> (largest scale). These interactions are inverse-leaning. In heterochiral triads, the transfer pathways are typically consistent with the standard forward cascade, moving energy to larger wavenumbers.<br>
The intuition is, mixing opposite handedness gives the nonlinear term more efficient routes to shred structures into smaller scales, while restricting the system to one-handedness removes many of those effificient downscale channels and leaves a route that can pump energy upscale.</p>
<p>Kraichnan's explanation for the 2D inverse cascade is tied to having two sign-definite inviscid invariants (energy and enstrophy). In 3D, helicity is usually sign-indefinite, so it doesn't constrain the cascade direction the same way.<br>
But in a strongly parity-broken state where only one helical sector exists (say <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover accent="true"><mi>u</mi><mo>^</mo></mover><mo>−</mo></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\hat{u}^-=0</annotation></semantics></math></span> everywhere), then</p>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi mathvariant="script">H</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi mathvariant="bold">k</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi mathvariant="normal">∣</mi><msup><mover accent="true"><mi>u</mi><mo>^</mo></mover><mo>+</mo></msup><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\hat{\mathcal{H}}(\mathbf{k})=k|\hat{u}^+|^2 \geq 0
</annotation></semantics></math></span></p>
<p>becomes sign-definite. The dynamics effectively have positive energy, and also positive helicity, which can impose constraints reminiscent of the 2D situation, and therefore support an inverse transfer.</p>
<p><a href="https://doi.org/10.1017/jfm.2013.637">Moffatt (2014)</a> emphasized that Waleffe's argument concerns isolated traids in the full Navier-Stokes system, triads are coupled in a dense network, so the net outcome is not guaranteed by single-triad reasoning alone.</p>
<p>A full triad coupling is too complex for a clean analytic proof, one can always run a numerical simulation.<br>
Biferale, Musacchio, and Toschi (2012) performed DNS of a modified system obtained by Galerkin projecting the velocity field onto a single helical sector (keeping only <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">u</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\mathbf{u}^+</annotation></semantics></math></span> or only <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">u</mi><mo>−</mo></msup></mrow><annotation encoding="application/x-tex">\mathbf{u}^-</annotation></semantics></math></span>), it follows:</p>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="normal">∂</mi><mi>t</mi></msub><msup><mi mathvariant="bold">u</mi><mi>s</mi></msup><mo>=</mo><mo>−</mo><mo stretchy="false">(</mo><msup><mi mathvariant="bold">u</mi><mi>s</mi></msup><mo>⋅</mo><mi mathvariant="normal">∇</mi><msup><mi mathvariant="bold">u</mi><mi>s</mi></msup><mo>−</mo><mi mathvariant="normal">∇</mi><mi>p</mi><msup><mo stretchy="false">)</mo><mi>s</mi></msup><mo>+</mo><mi>ν</mi><msup><mi mathvariant="normal">∇</mi><mn>2</mn></msup><msup><mi mathvariant="bold">u</mi><mi>s</mi></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\partial_{t} \mathbf{u}^s = -(\mathbf{u}^s \cdot \nabla \mathbf{u}^s - \nabla p)^s + \nu \nabla^2 \mathbf{u}^s.
</annotation></semantics></math></span></p>
<p>The resulting &quot;homochiral Navier-Stokes&quot; dynamics preserve only homochiral interactions. In the setup, helicity has a fixed sign, parity symmetry is explicitly broken, and the energy cascade switches from forward to fully inverse, energy injected at small scales is transported to larger scales.<br>
Their spectra show large-scale energy growth and a Kolmogorov-like <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>5</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">-5/3</annotation></semantics></math></span> scaling with the inverse transfer, while small-scale energy stays nearly unchanged, consistent with the idea that the downscale route has been largely removed.</p>
<figure class="center-figure">
  <img src="https://ar5iv.labs.arxiv.org/html/1111.1412/assets/fig2.png" width="400">
  <figcaption><a href="https://ar5iv.labs.arxiv.org/html/1111.1412">Biferale et al., 2012</a></figcaption>
</figure>
<p>Later numerical work suggests this inverse-cascade regime is fragile: introducing even a small fraction of heterochiral interactions can quickly restore the usual forward cascade. The switch behaves like a phase transition, only nearly pure chirality produces a robust inverse cascade. This fragility also helps explain why ordinary 3D turbulence, which naturally mixes both helicities, is dominated by forward cascade.</p>
<h2 id="quasi-two-dimensional-flows" tabindex="-1">(Quasi-)two-dimensional flows</h2>
<p>Inverse cascades are well-known in flows that are 2D or nearly 2D-geophysical flows (oceans, atmosphere) or strongly anisotrpic system (e.g., rapid rotation). The natural hypothesis is,</p>
<blockquote>
<p>If a globally 3D flow develops locally quasi-2D motion, then inverse transfer can appear in those regions.</p>
</blockquote>
<p>A common physical diagnostic uses low-pass filtering (LES-like). Filtering the incompressible Navier-Stokes gives an energy transfer between resolved, filtered scales and subgrid scales,</p>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Π</mi><mo>=</mo><mo>−</mo><msub><mover accent="true"><mi>τ</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mover accent="true"><mi>S</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">\Pi = -\tilde{\tau}_{ij} \tilde{S}_{ij},
</annotation></semantics></math></span></p>
<p>where <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>τ</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mover accent="true"><mrow><msub><mi>u</mi><mi>i</mi></msub><msub><mi>u</mi><mi>j</mi></msub></mrow><mo>~</mo></mover><mo>−</mo><mover accent="true"><msub><mi>u</mi><mi>i</mi></msub><mo>~</mo></mover><mover accent="true"><msub><mi>u</mi><mi>j</mi></msub><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{\tau}_{ij}=\tilde{u_{i}u_{j}} -\tilde{u_{i}}\tilde{u_{j}}</annotation></semantics></math></span> is the subgrid stress, and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>S</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\tilde{S}_{ij}</annotation></semantics></math></span> is the filtered strain-rate tensor.<br>
If we see <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math></span> as the &quot;inner-product&quot; of the two tensors. Its magnitude depends strongly on their relative alignment. If we denote the eigenvalues and eigenvectors by</p>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="bold">e</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">g</mi></mrow><mo stretchy="false">(</mo><msub><mover accent="true"><mi>τ</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>σ</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>σ</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>σ</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mrow><mi mathvariant="bold">e</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">g</mi></mrow><mo stretchy="false">(</mo><msub><mover accent="true"><mi>S</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>λ</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>λ</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>λ</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">\mathbf{eig}(\tilde{\tau}_{ij})=(\sigma_{1},\sigma_{2},\sigma_{3}), \mathbf{eig}(\tilde{S}_{ij})=(\lambda_{1},\lambda_{2},\lambda_{3}),
</annotation></semantics></math></span></p>
<p>and describe the relative rotation between their eigenframes by Euler angles <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>ϕ</mi><mo separator="true">,</mo><mi>θ</mi><mo separator="true">,</mo><mi>φ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\phi,\theta,\varphi)</annotation></semantics></math></span>, then</p>
<p class='katex-block'><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">Π</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>σ</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>λ</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>ϕ</mi><mo separator="true">,</mo><mi>θ</mi><mo separator="true">,</mo><mi>φ</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\Pi = f(\sigma_{i},\lambda_{i},\phi,\theta,\varphi).
</annotation></semantics></math></span></p>
<p>If the eigenframes align strongly, the contraction <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mover accent="true"><mi>τ</mi><mo>~</mo></mover><mo>:</mo><mover accent="true"><mi>S</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">-\tilde{\tau}:\tilde{S}</annotation></semantics></math></span> can be large in magnitude, hence an efficient scale-to-scale transfer, vice versa. Eddy-viscosity closures often assume <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>τ</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>∝</mo><mo>−</mo><msub><mover accent="true"><mi>S</mi><mo>~</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\tilde{\tau}_{ij}\propto -\tilde{S}_{ij}</annotation></semantics></math></span>, i.e. strong alignment by construction. But this assumption can artificially maximize <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Π</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\Pi|</annotation></semantics></math></span>, contributing to the tendency of such models to be over-dissipative.</p>
<p>In an idealized 2D limit, the strain and stress structures exhibit paired eigenvalues (e.g. <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mn>1</mn></msub><mo>=</mo><mo>−</mo><msub><mi>λ</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">\lambda_{1}=-\lambda_{3}</annotation></semantics></math></span>), reflecting the reduced dimensionality. As the local dynamics approach this limit, the transfer geometry changes: the standard 3D downscale route becomes less effective, and backscatter or inverse transfer becomes more likely. So the quasi-2D route to inverse cascade is not &quot;helicity-domanited,&quot; but effective reduction of degrees of freedom and a corresponding reconfiguration of how nonlinear transfer can continue.</p>

              </div>
            
          
        </td>
      </tr>
    </table>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        if (window.Han) {
          document.querySelectorAll(".han-init-context").forEach((element) => {
            Han(element).render();
          });
        }
      });
    </script>
  </body>
</html>
